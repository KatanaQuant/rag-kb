"""Advanced malware detection strategies

Implements three layers of malware detection:
1. ClamAV integration - Virus signature scanning (CRITICAL severity)
2. Hash-based blacklist - Known malware database (CRITICAL severity)
3. YARA rules - Custom pattern matching (WARNING severity by default)

All three are optional and can be enabled/disabled via configuration.

Severity tiers:
- CRITICAL: Auto-quarantine + remove from DB (ClamAV virus, hash blacklist)
- WARNING: Log + flag, user decides (YARA pattern matches)
- INFO: Log only (informational, low-confidence)

Performance optimization:
- Scan results are cached by file hash (SHA256)
- Unchanged files skip ClamAV/YARA scans on subsequent checks
- Cache is invalidated when file content changes (new hash)
"""
from pathlib import Path
from typing import Optional, List, Dict, Set
import hashlib
from dataclasses import dataclass, field

from ingestion.validation_result import ValidationResult, SecuritySeverity, SecurityMatch


@dataclass
class MalwareDetectionConfig:
    """Configuration for malware detection features"""
    clamav_enabled: bool = False
    clamav_socket: str = "/var/run/clamav/clamd.ctl"
    hash_blacklist_enabled: bool = False
    hash_blacklist_path: str = "/app/data/malware_hashes.txt"
    yara_enabled: bool = False
    yara_rules_path: str = "/app/config/yara_rules.yar"
    # Allowlist for known-safe files (skip all security checks)
    allowlist_path: str = "/app/data/security_allowlist.txt"
    # YARA rules that should only produce warnings (not block)
    yara_warning_only: bool = True  # Default: YARA matches are warnings, not blocks


class ClamAVStrategy:
    """Virus signature scanning using ClamAV

    Requires ClamAV daemon (clamd) to be running.
    Install: apt-get install clamav-daemon
    """

    def __init__(self, socket_path: str = "/var/run/clamav/clamd.ctl"):
        """Initialize ClamAV scanner

        Args:
            socket_path: Path to ClamAV unix socket
        """
        self.socket_path = socket_path
        self._clamd = None

    def _get_client(self):
        """Get ClamAV client (lazy initialization)"""
        if self._clamd is None:
            try:
                import clamd
                self._clamd = clamd.ClamdUnixSocket(self.socket_path)
                # Test connection
                self._clamd.ping()
            except ImportError:
                raise RuntimeError(
                    "ClamAV integration requires 'clamd' package. "
                    "Install with: pip install clamd"
                )
            except Exception as e:
                raise RuntimeError(
                    f"Cannot connect to ClamAV daemon at {self.socket_path}. "
                    f"Ensure clamd is running. Error: {e}"
                )
        return self._clamd

    def validate(self, file_path: Path, expected_type: str) -> ValidationResult:
        """Scan file for viruses using ClamAV

        Args:
            file_path: Path to file to scan
            expected_type: Expected file type

        Returns:
            ValidationResult with is_valid=False and CRITICAL severity if malware detected
        """
        try:
            client = self._get_client()
            scan_result = client.scan(str(file_path))

            # scan_result format: {'/path/to/file': ('FOUND', 'Virus.Name')}
            if scan_result:
                for path, (status, virus_name) in scan_result.items():
                    if status == 'FOUND':
                        return ValidationResult(
                            is_valid=False,
                            file_type='malware',
                            reason=f'Virus detected: {virus_name}',
                            validation_check='ClamAVStrategy',
                            severity=SecuritySeverity.CRITICAL,
                            matches=[SecurityMatch(
                                rule_name=virus_name,
                                severity=SecuritySeverity.CRITICAL,
                                description=f'ClamAV signature match: {virus_name}'
                            )]
                        )

            return ValidationResult(
                is_valid=True,
                file_type=expected_type,
                reason=''
            )

        except RuntimeError as e:
            # ClamAV not available - log warning but don't fail
            print(f"  ⚠️  ClamAV scan skipped: {e}")
            return ValidationResult(
                is_valid=True,
                file_type=expected_type,
                reason=''
            )
        except Exception as e:
            # Unexpected error - log but don't fail validation
            print(f"  ⚠️  ClamAV scan error: {e}")
            return ValidationResult(
                is_valid=True,
                file_type=expected_type,
                reason=''
            )


class HashBlacklistStrategy:
    """Hash-based malware blacklist

    Checks file SHA256 hash against known malware database.
    Blacklist format: One SHA256 hash per line (hex format)

    Example blacklist file:
        # VirusTotal known malware
        d41d8cd98f00b204e9800998ecf8427e
        098f6bcd4621d373cade4e832627b4f6
        # Custom blacklist
        abc123def456...
    """

    def __init__(self, blacklist_path: Optional[str] = "/app/data/malware_hashes.txt"):
        """Initialize hash blacklist

        Args:
            blacklist_path: Path to blacklist file (None to disable)
        """
        self.blacklist_path = Path(blacklist_path) if blacklist_path else None
        self._blacklist: Optional[set] = None

    def _load_blacklist(self) -> set:
        """Load blacklist from file (lazy loading)

        Returns:
            Set of blacklisted hashes (lowercase)
        """
        if self._blacklist is None:
            self._blacklist = set()

            if self.blacklist_path is None:
                return self._blacklist

            if not self.blacklist_path.exists():
                print(f"  ⚠️  Hash blacklist not found: {self.blacklist_path}")
                print(f"     Create file with one SHA256 hash per line")
                return self._blacklist

            try:
                with open(self.blacklist_path, 'r') as f:
                    for line in f:
                        line = line.strip()
                        # Skip comments and empty lines
                        if line and not line.startswith('#'):
                            # Store lowercase for case-insensitive comparison
                            self._blacklist.add(line.lower())

                print(f"  ✓ Loaded {len(self._blacklist)} hashes from blacklist")

            except Exception as e:
                print(f"  ⚠️  Failed to load hash blacklist: {e}")

        return self._blacklist

    def validate(self, file_path: Path, expected_type: str) -> ValidationResult:
        """Check file hash against blacklist

        Args:
            file_path: Path to file to check
            expected_type: Expected file type

        Returns:
            ValidationResult with is_valid=False and CRITICAL severity if hash is blacklisted
        """
        blacklist = self._load_blacklist()

        if not blacklist:
            # No blacklist loaded, pass validation
            return ValidationResult(
                is_valid=True,
                file_type=expected_type,
                reason=''
            )

        try:
            # Calculate SHA256 hash
            file_hash = self._calculate_sha256(file_path)

            # Check against blacklist
            if file_hash.lower() in blacklist:
                return ValidationResult(
                    is_valid=False,
                    file_type='malware',
                    reason=f'Known malware hash: {file_hash[:16]}...',
                    validation_check='HashBlacklistStrategy',
                    severity=SecuritySeverity.CRITICAL,
                    matches=[SecurityMatch(
                        rule_name='HashBlacklist',
                        severity=SecuritySeverity.CRITICAL,
                        description=f'SHA256 hash matches known malware database',
                        context=f'hash={file_hash}'
                    )]
                )

            return ValidationResult(
                is_valid=True,
                file_type=expected_type,
                reason=''
            )

        except Exception as e:
            print(f"  ⚠️  Hash blacklist check error: {e}")
            return ValidationResult(
                is_valid=True,
                file_type=expected_type,
                reason=''
            )

    @staticmethod
    def _calculate_sha256(file_path: Path) -> str:
        """Calculate SHA256 hash of file

        Args:
            file_path: Path to file

        Returns:
            Hex-encoded SHA256 hash
        """
        sha256_hash = hashlib.sha256()
        with open(file_path, "rb") as f:
            # Read in chunks to handle large files
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        return sha256_hash.hexdigest()


class YARAStrategy:
    """YARA rule-based pattern matching

    Custom pattern matching for malware detection.
    Install: pip install yara-python

    Example YARA rule file:
        rule SuspiciousScript {
            strings:
                $cmd1 = "rm -rf /" nocase
                $cmd2 = "curl | bash" nocase
                $cmd3 = "wget | sh" nocase
            condition:
                any of them
        }

        rule Cryptocurrency_Miner {
            strings:
                $str1 = "stratum+tcp://"
                $str2 = "xmrig"
                $str3 = "cryptonight"
            condition:
                any of them
        }
    """

    def __init__(self, rules_path: Optional[str] = "/app/config/yara_rules.yar"):
        """Initialize YARA scanner

        Args:
            rules_path: Path to YARA rules file (None to disable)
        """
        self.rules_path = Path(rules_path) if rules_path else None
        self._rules = None

    def _load_rules(self):
        """Load YARA rules (lazy loading)"""
        if self._rules is None:
            try:
                import yara

                if self.rules_path is None:
                    return None

                if not self.rules_path.exists():
                    print(f"  ⚠️  YARA rules not found: {self.rules_path}")
                    print(f"     Create .yar file with YARA rules")
                    return None

                self._rules = yara.compile(filepath=str(self.rules_path))
                print(f"  ✓ Loaded YARA rules from {self.rules_path}")

            except ImportError:
                print("  ⚠️  YARA integration requires 'yara-python' package.")
                print("     Install with: pip install yara-python")
                return None
            except Exception as e:
                print(f"  ⚠️  Failed to load YARA rules: {e}")
                return None

        return self._rules

    def validate(self, file_path: Path, expected_type: str,
                 warning_only: bool = True) -> ValidationResult:
        """Scan file with YARA rules

        Args:
            file_path: Path to file to scan
            expected_type: Expected file type
            warning_only: If True, matches are WARNING severity (default)
                          If False, matches are CRITICAL severity

        Returns:
            ValidationResult with WARNING/CRITICAL severity based on warning_only
        """
        rules = self._load_rules()

        if rules is None:
            # YARA not available, pass validation
            return ValidationResult(
                is_valid=True,
                file_type=expected_type,
                reason=''
            )

        try:
            # Scan file with YARA rules
            matches = rules.match(filepath=str(file_path))

            if matches:
                # Determine severity based on config
                severity = SecuritySeverity.WARNING if warning_only else SecuritySeverity.CRITICAL

                # Build detailed match info
                security_matches = []
                for match in matches:
                    # Get match details including offsets
                    match_strings = []
                    for string_match in match.strings:
                        # string_match: (offset, identifier, data)
                        for instance in string_match.instances:
                            match_strings.append({
                                'offset': instance.offset,
                                'identifier': string_match.identifier,
                                'length': instance.matched_length
                            })

                    # Get rule metadata for context
                    meta = match.meta
                    description = meta.get('description', f'YARA rule: {match.rule}')
                    rule_severity = meta.get('severity', 'medium')

                    # Provide context hints for likely false positives
                    context = self._get_false_positive_hint(match.rule, file_path, match_strings)

                    security_matches.append(SecurityMatch(
                        rule_name=match.rule,
                        severity=severity,
                        description=description,
                        offset=match_strings[0]['offset'] if match_strings else None,
                        context=context
                    ))

                rule_names = [match.rule for match in matches]

                # For warnings, is_valid=True but we still report the match
                return ValidationResult(
                    is_valid=warning_only,  # Valid if warning_only, invalid if critical
                    file_type='suspicious' if not warning_only else expected_type,
                    reason=f'YARA rules matched: {", ".join(rule_names)}',
                    validation_check='YARAStrategy',
                    severity=severity,
                    matches=security_matches
                )

            return ValidationResult(
                is_valid=True,
                file_type=expected_type,
                reason=''
            )

        except Exception as e:
            print(f"  ⚠️  YARA scan error: {e}")
            return ValidationResult(
                is_valid=True,
                file_type=expected_type,
                reason=''
            )

    def _get_false_positive_hint(self, rule_name: str, file_path: Path,
                                  match_strings: List[Dict]) -> str:
        """Provide context hints for likely false positives

        Args:
            rule_name: Name of matched YARA rule
            file_path: Path to scanned file
            match_strings: List of match details

        Returns:
            Context string with hints about likely false positives
        """
        ext = file_path.suffix.lower()
        hints = []

        # PDF-specific false positive hints
        if ext == '.pdf':
            if rule_name == 'Suspicious_Embedded_Executable':
                hints.append('PDFs often contain MZ headers in embedded fonts')
            if rule_name == 'Large_Obfuscated_Data':
                hints.append('PDFs use base64 for embedded images/fonts')
            if rule_name == 'Suspicious_Shellcode':
                hints.append('Common byte patterns in PDF stream data')

        # Code file hints
        if ext in ('.py', '.js', '.ts', '.go', '.java'):
            if rule_name == 'Suspicious_Archive_Content':
                hints.append('Code may reference file extensions in strings')

        if hints:
            return f'Likely false positive: {"; ".join(hints)}'
        return ''


class AdvancedMalwareDetector:
    """Combines all malware detection strategies

    Integrates:
    - ClamAV virus scanning (CRITICAL severity)
    - Hash-based blacklist (CRITICAL severity)
    - YARA pattern matching (WARNING severity by default)

    All three are optional and configured independently.

    Severity-based actions:
    - CRITICAL: Auto-quarantine, delete from DB
    - WARNING: Log and flag, user decides
    - INFO: Log only
    """

    def __init__(self, config: Optional[MalwareDetectionConfig] = None):
        """Initialize malware detector

        Args:
            config: Detection configuration (uses defaults if None)
        """
        self.config = config or MalwareDetectionConfig()

        # Initialize enabled strategies
        self.clamav = None
        self.hash_blacklist = None
        self.yara = None
        self._allowlist: Optional[Set[str]] = None

        if self.config.clamav_enabled:
            self.clamav = ClamAVStrategy(self.config.clamav_socket)

        if self.config.hash_blacklist_enabled:
            self.hash_blacklist = HashBlacklistStrategy(self.config.hash_blacklist_path)

        if self.config.yara_enabled:
            self.yara = YARAStrategy(self.config.yara_rules_path)

    def _load_allowlist(self) -> Set[str]:
        """Load allowlist of known-safe file hashes

        Returns:
            Set of SHA256 hashes (lowercase) that should skip security checks
        """
        if self._allowlist is None:
            self._allowlist = set()
            allowlist_path = Path(self.config.allowlist_path)

            if allowlist_path.exists():
                try:
                    with open(allowlist_path, 'r') as f:
                        for line in f:
                            line = line.strip()
                            if line and not line.startswith('#'):
                                self._allowlist.add(line.lower())
                    if self._allowlist:
                        print(f"  ✓ Loaded {len(self._allowlist)} hashes from allowlist")
                except Exception as e:
                    print(f"  ⚠️  Failed to load allowlist: {e}")

        return self._allowlist

    def is_allowlisted(self, file_path: Path) -> bool:
        """Check if file is in allowlist (skip all security checks)

        Args:
            file_path: Path to file to check

        Returns:
            True if file hash is in allowlist
        """
        allowlist = self._load_allowlist()
        if not allowlist:
            return False

        try:
            file_hash = HashBlacklistStrategy._calculate_sha256(file_path)
            return file_hash.lower() in allowlist
        except Exception:
            return False

    def validate(self, file_path: Path, expected_type: str) -> ValidationResult:
        """Run all enabled malware detection strategies

        Uses caching to skip expensive scans for unchanged files.
        Cache key is the file's SHA256 hash.

        Args:
            file_path: Path to file to scan
            expected_type: Expected file type

        Returns:
            ValidationResult with severity-based action hints
        """
        # Check allowlist first - skip all checks if allowlisted
        if self.is_allowlisted(file_path):
            return ValidationResult(
                is_valid=True,
                file_type=expected_type,
                reason='Allowlisted'
            )

        # Calculate file hash for cache lookup
        try:
            file_hash = HashBlacklistStrategy._calculate_sha256(file_path)
        except Exception:
            file_hash = None

        # Check cache first (skip expensive scans for unchanged files)
        if file_hash:
            cached = self._get_cached_result(file_hash, expected_type)
            if cached:
                return cached

        # Run actual scans
        result = self._run_scans(file_path, expected_type)

        # Cache the result
        if file_hash:
            self._cache_result(file_hash, result)

        return result

    def _get_cached_result(self, file_hash: str, expected_type: str) -> Optional[ValidationResult]:
        """Check cache for previous scan result

        Args:
            file_hash: SHA256 hash of file
            expected_type: Expected file type

        Returns:
            Cached ValidationResult if found, None otherwise
        """
        try:
            from services.security_scan_cache import get_security_cache

            cache = get_security_cache()
            cached = cache.get(file_hash)

            if cached:
                # Reconstruct ValidationResult from cache
                severity = None
                if cached.severity:
                    severity = SecuritySeverity(cached.severity)

                # Reconstruct matches
                matches = []
                for m in cached.matches:
                    match_severity = SecuritySeverity(m.get('severity', 'WARNING'))
                    matches.append(SecurityMatch(
                        rule_name=m.get('rule_name', 'Unknown'),
                        severity=match_severity,
                        description=m.get('description', ''),
                        offset=m.get('offset'),
                        context=m.get('context', '')
                    ))

                return ValidationResult(
                    is_valid=cached.is_valid,
                    file_type=expected_type if cached.is_valid else 'malware',
                    reason=cached.reason,
                    validation_check=cached.validation_check,
                    severity=severity,
                    matches=matches
                )
        except Exception:
            # Cache not available - fall through to scan
            pass

        return None

    def _cache_result(self, file_hash: str, result: ValidationResult) -> None:
        """Cache scan result for future lookups

        Args:
            file_hash: SHA256 hash of file
            result: ValidationResult to cache
        """
        try:
            from services.security_scan_cache import get_security_cache

            cache = get_security_cache()

            # Serialize matches for storage
            matches = []
            for m in (result.matches or []):
                matches.append({
                    'rule_name': m.rule_name,
                    'severity': m.severity.value if m.severity else 'WARNING',
                    'description': m.description,
                    'offset': m.offset,
                    'context': m.context
                })

            cache.set(
                file_hash=file_hash,
                is_valid=result.is_valid,
                severity=result.severity.value if result.severity else None,
                reason=result.reason,
                validation_check=result.validation_check or '',
                matches=matches
            )
        except Exception:
            # Cache not available - continue without caching
            pass

    def _run_scans(self, file_path: Path, expected_type: str) -> ValidationResult:
        """Run all enabled malware detection scans

        Args:
            file_path: Path to file to scan
            expected_type: Expected file type

        Returns:
            ValidationResult from scans
        """
        # Collect all warnings (YARA matches)
        warnings: List[SecurityMatch] = []

        # Check ClamAV first (CRITICAL - blocks immediately)
        if self.clamav:
            result = self.clamav.validate(file_path, expected_type)
            if not result.is_valid:
                return result

        # Check hash blacklist (CRITICAL - blocks immediately)
        if self.hash_blacklist:
            result = self.hash_blacklist.validate(file_path, expected_type)
            if not result.is_valid:
                return result

        # Check YARA rules (WARNING by default - doesn't block)
        if self.yara:
            result = self.yara.validate(
                file_path, expected_type,
                warning_only=self.config.yara_warning_only
            )
            if result.matches:
                warnings.extend(result.matches)
            # Only block if yara_warning_only is False
            if not result.is_valid:
                return result

        # All checks passed, but may have warnings
        if warnings:
            return ValidationResult(
                is_valid=True,  # Allow processing with warnings
                file_type=expected_type,
                reason=f'Warnings: {len(warnings)} pattern matches',
                severity=SecuritySeverity.WARNING,
                matches=warnings
            )

        return ValidationResult(
            is_valid=True,
            file_type=expected_type,
            reason=''
        )

    def is_enabled(self) -> bool:
        """Check if any malware detection is enabled

        Returns:
            True if at least one strategy is enabled
        """
        return any([
            self.config.clamav_enabled,
            self.config.hash_blacklist_enabled,
            self.config.yara_enabled
        ])
