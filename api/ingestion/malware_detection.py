"""Advanced malware detection strategies

Implements three layers of malware detection:
1. ClamAV integration - Virus signature scanning (CRITICAL severity)
2. Hash-based blacklist - Known malware database (CRITICAL severity)
3. YARA rules - Custom pattern matching (WARNING severity by default)

All three are optional and can be enabled/disabled via configuration.

Severity tiers:
- CRITICAL: Auto-quarantine + remove from DB (ClamAV virus, hash blacklist)
- WARNING: Log + flag, user decides (YARA pattern matches)
- INFO: Log only (informational, low-confidence)

Performance optimization:
- Scan results are cached by file hash (SHA256)
- Unchanged files skip ClamAV/YARA scans on subsequent checks
- Cache is invalidated when file content changes (new hash)
- ClamAV uses thread-local connections to avoid socket contention
"""
from pathlib import Path
from typing import Optional, List, Dict, Set
import hashlib
import threading
from dataclasses import dataclass, field

from ingestion.validation_result import ValidationResult, SecuritySeverity, SecurityMatch


def _load_hash_list(file_path: Optional[Path], list_name: str) -> Set[str]:
    """Load a set of hashes from a file

    Args:
        file_path: Path to hash list file (one SHA256 per line)
        list_name: Name for logging (e.g., "blacklist", "allowlist")

    Returns:
        Set of lowercase hashes
    """
    if not file_path or not file_path.exists():
        return set()

    try:
        hashes = _parse_hash_file(file_path)
        if hashes:
            print(f"  Loaded {len(hashes)} hashes from {list_name}")
        return hashes
    except Exception as e:
        print(f"  Warning: Failed to load {list_name}: {e}")
        return set()


def _parse_hash_file(file_path: Path) -> Set[str]:
    """Parse hash file, ignoring comments and blank lines"""
    hashes = set()
    with open(file_path, 'r') as f:
        for line in f:
            line = line.strip()
            if line and not line.startswith('#'):
                hashes.add(line.lower())
    return hashes


@dataclass
class MalwareDetectionConfig:
    """Configuration for malware detection features"""
    clamav_enabled: bool = False
    clamav_socket: str = "/var/run/clamav/clamd.ctl"
    hash_blacklist_enabled: bool = False
    hash_blacklist_path: str = "/app/data/malware_hashes.txt"
    yara_enabled: bool = False
    yara_rules_path: str = "/app/config/yara_rules.yar"
    # Allowlist for known-safe files (skip all security checks)
    allowlist_path: str = "/app/data/security_allowlist.txt"
    # YARA rules that should only produce warnings (not block)
    yara_warning_only: bool = True  # Default: YARA matches are warnings, not blocks


class ClamAVStrategy:
    """Virus signature scanning using ClamAV

    Requires ClamAV daemon (clamd) to be running.
    Install: apt-get install clamav-daemon

    Uses thread-local connections to avoid socket contention when
    multiple workers scan files in parallel.
    """

    def __init__(self, socket_path: str = "/var/run/clamav/clamd.ctl"):
        """Initialize ClamAV scanner

        Args:
            socket_path: Path to ClamAV unix socket
        """
        self.socket_path = socket_path
        # Thread-local storage for per-thread connections
        self._local = threading.local()

    def _get_client(self):
        """Get ClamAV client for current thread (thread-local)

        Each thread gets its own connection to avoid socket contention
        when multiple workers scan files in parallel.
        """
        # Check if this thread has a client
        if not hasattr(self._local, 'clamd'):
            try:
                import clamd
                self._local.clamd = clamd.ClamdUnixSocket(self.socket_path)
                # Test connection
                self._local.clamd.ping()
            except ImportError:
                raise RuntimeError(
                    "ClamAV integration requires 'clamd' package. "
                    "Install with: pip install clamd"
                )
            except Exception as e:
                raise RuntimeError(
                    f"Cannot connect to ClamAV daemon at {self.socket_path}. "
                    f"Ensure clamd is running. Error: {e}"
                )
        return self._local.clamd

    def validate(self, file_path: Path, expected_type: str) -> ValidationResult:
        """Scan file for viruses using ClamAV

        Args:
            file_path: Path to file to scan
            expected_type: Expected file type

        Returns:
            ValidationResult with is_valid=False and CRITICAL severity if malware detected
        """
        try:
            client = self._get_client()
            scan_result = client.scan(str(file_path))

            # scan_result format: {'/path/to/file': ('FOUND', 'Virus.Name')}
            if scan_result:
                for path, (status, virus_name) in scan_result.items():
                    if status == 'FOUND':
                        return ValidationResult(
                            is_valid=False,
                            file_type='malware',
                            reason=f'Virus detected: {virus_name}',
                            validation_check='ClamAVStrategy',
                            severity=SecuritySeverity.CRITICAL,
                            matches=[SecurityMatch(
                                rule_name=virus_name,
                                severity=SecuritySeverity.CRITICAL,
                                description=f'ClamAV signature match: {virus_name}'
                            )]
                        )

            return ValidationResult(
                is_valid=True,
                file_type=expected_type,
                reason=''
            )

        except RuntimeError as e:
            # ClamAV not available - log warning but don't fail
            print(f"  ⚠️  ClamAV scan skipped: {e}")
            return ValidationResult(
                is_valid=True,
                file_type=expected_type,
                reason=''
            )
        except Exception as e:
            # Unexpected error - log but don't fail validation
            print(f"  ⚠️  ClamAV scan error: {e}")
            return ValidationResult(
                is_valid=True,
                file_type=expected_type,
                reason=''
            )


class HashBlacklistStrategy:
    """Hash-based malware blacklist

    Checks file SHA256 hash against known malware database.
    Blacklist format: One SHA256 hash per line (hex format)

    Example blacklist file:
        # VirusTotal known malware
        d41d8cd98f00b204e9800998ecf8427e
        098f6bcd4621d373cade4e832627b4f6
        # Custom blacklist
        abc123def456...
    """

    def __init__(self, blacklist_path: Optional[str] = "/app/data/malware_hashes.txt"):
        """Initialize hash blacklist

        Args:
            blacklist_path: Path to blacklist file (None to disable)
        """
        self.blacklist_path = Path(blacklist_path) if blacklist_path else None
        self._blacklist: Optional[set] = None

    def _load_blacklist(self) -> set:
        """Load blacklist from file (lazy loading)

        Returns:
            Set of blacklisted hashes (lowercase)
        """
        if self._blacklist is None:
            self._blacklist = _load_hash_list(self.blacklist_path, "blacklist")
        return self._blacklist

    def validate(self, file_path: Path, expected_type: str) -> ValidationResult:
        """Check file hash against blacklist

        Args:
            file_path: Path to file to check
            expected_type: Expected file type

        Returns:
            ValidationResult with is_valid=False and CRITICAL severity if hash is blacklisted
        """
        blacklist = self._load_blacklist()

        if not blacklist:
            # No blacklist loaded, pass validation
            return ValidationResult(
                is_valid=True,
                file_type=expected_type,
                reason=''
            )

        try:
            # Calculate SHA256 hash
            file_hash = self._calculate_sha256(file_path)

            # Check against blacklist
            if file_hash.lower() in blacklist:
                return ValidationResult(
                    is_valid=False,
                    file_type='malware',
                    reason=f'Known malware hash: {file_hash[:16]}...',
                    validation_check='HashBlacklistStrategy',
                    severity=SecuritySeverity.CRITICAL,
                    matches=[SecurityMatch(
                        rule_name='HashBlacklist',
                        severity=SecuritySeverity.CRITICAL,
                        description=f'SHA256 hash matches known malware database',
                        context=f'hash={file_hash}'
                    )]
                )

            return ValidationResult(
                is_valid=True,
                file_type=expected_type,
                reason=''
            )

        except Exception as e:
            print(f"  ⚠️  Hash blacklist check error: {e}")
            return ValidationResult(
                is_valid=True,
                file_type=expected_type,
                reason=''
            )

    @staticmethod
    def _calculate_sha256(file_path: Path) -> str:
        """Calculate SHA256 hash of file

        Args:
            file_path: Path to file

        Returns:
            Hex-encoded SHA256 hash
        """
        sha256_hash = hashlib.sha256()
        with open(file_path, "rb") as f:
            # Read in chunks to handle large files
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        return sha256_hash.hexdigest()


class YARAStrategy:
    """YARA rule-based pattern matching

    Custom pattern matching for malware detection.
    Install: pip install yara-python

    Example YARA rule file:
        rule SuspiciousScript {
            strings:
                $cmd1 = "rm -rf /" nocase
                $cmd2 = "curl | bash" nocase
                $cmd3 = "wget | sh" nocase
            condition:
                any of them
        }

        rule Cryptocurrency_Miner {
            strings:
                $str1 = "stratum+tcp://"
                $str2 = "xmrig"
                $str3 = "cryptonight"
            condition:
                any of them
        }
    """

    def __init__(self, rules_path: Optional[str] = "/app/config/yara_rules.yar"):
        """Initialize YARA scanner

        Args:
            rules_path: Path to YARA rules file (None to disable)
        """
        self.rules_path = Path(rules_path) if rules_path else None
        self._rules = None

    def _load_rules(self):
        """Load YARA rules (lazy loading)"""
        if self._rules is None:
            try:
                import yara

                if self.rules_path is None:
                    return None

                if not self.rules_path.exists():
                    print(f"  ⚠️  YARA rules not found: {self.rules_path}")
                    print(f"     Create .yar file with YARA rules")
                    return None

                self._rules = yara.compile(filepath=str(self.rules_path))
                print(f"  ✓ Loaded YARA rules from {self.rules_path}")

            except ImportError:
                print("  ⚠️  YARA integration requires 'yara-python' package.")
                print("     Install with: pip install yara-python")
                return None
            except Exception as e:
                print(f"  ⚠️  Failed to load YARA rules: {e}")
                return None

        return self._rules

    def validate(self, file_path: Path, expected_type: str,
                 warning_only: bool = True) -> ValidationResult:
        """Scan file with YARA rules

        Args:
            file_path: Path to file to scan
            expected_type: Expected file type
            warning_only: If True, matches are WARNING severity (default)
                          If False, matches are CRITICAL severity

        Returns:
            ValidationResult with WARNING/CRITICAL severity based on warning_only
        """
        rules = self._load_rules()

        if rules is None:
            return self._no_rules_result(expected_type)

        try:
            matches = rules.match(filepath=str(file_path))

            if not matches:
                return self._clean_result(expected_type)

            return self._build_match_result(matches, file_path, expected_type, warning_only)

        except Exception as e:
            print(f"  ⚠️  YARA scan error: {e}")
            return self._clean_result(expected_type)

    def _no_rules_result(self, expected_type: str) -> ValidationResult:
        """Return result when YARA rules not available"""
        return ValidationResult(
            is_valid=True,
            file_type=expected_type,
            reason=''
        )

    def _clean_result(self, expected_type: str) -> ValidationResult:
        """Return result for clean file (no matches)"""
        return ValidationResult(
            is_valid=True,
            file_type=expected_type,
            reason=''
        )

    def _build_match_result(self, matches, file_path: Path,
                            expected_type: str, warning_only: bool) -> ValidationResult:
        """Build ValidationResult from YARA matches"""
        severity = SecuritySeverity.WARNING if warning_only else SecuritySeverity.CRITICAL
        security_matches = [
            self._build_security_match(match, file_path, severity)
            for match in matches
        ]
        rule_names = [match.rule for match in matches]

        return ValidationResult(
            is_valid=warning_only,
            file_type='suspicious' if not warning_only else expected_type,
            reason=f'YARA rules matched: {", ".join(rule_names)}',
            validation_check='YARAStrategy',
            severity=severity,
            matches=security_matches
        )

    def _build_security_match(self, match, file_path: Path,
                              severity: SecuritySeverity) -> SecurityMatch:
        """Build SecurityMatch from a single YARA match"""
        match_strings = self._extract_match_strings(match)
        meta = match.meta
        description = meta.get('description', f'YARA rule: {match.rule}')
        context = self._get_false_positive_hint(match.rule, file_path, match_strings)

        return SecurityMatch(
            rule_name=match.rule,
            severity=severity,
            description=description,
            offset=match_strings[0]['offset'] if match_strings else None,
            context=context
        )

    def _extract_match_strings(self, match) -> List[Dict]:
        """Extract string match details from YARA match"""
        match_strings = []
        for string_match in match.strings:
            for instance in string_match.instances:
                match_strings.append({
                    'offset': instance.offset,
                    'identifier': string_match.identifier,
                    'length': instance.matched_length
                })
        return match_strings

    # False positive hints by (extension_group, rule_name)
    _FALSE_POSITIVE_HINTS = {
        ('pdf', 'Suspicious_Embedded_Executable'): 'PDFs often contain MZ headers in embedded fonts',
        ('pdf', 'Large_Obfuscated_Data'): 'PDFs use base64 for embedded images/fonts',
        ('pdf', 'Suspicious_Shellcode'): 'Common byte patterns in PDF stream data',
        ('code', 'Suspicious_Archive_Content'): 'Code may reference file extensions in strings',
    }
    _CODE_EXTENSIONS = {'.py', '.js', '.ts', '.go', '.java'}

    def _get_false_positive_hint(self, rule_name: str, file_path: Path,
                                  match_strings: List[Dict]) -> str:
        """Provide context hints for likely false positives"""
        ext = file_path.suffix.lower()
        ext_group = 'pdf' if ext == '.pdf' else 'code' if ext in self._CODE_EXTENSIONS else None

        if ext_group:
            hint = self._FALSE_POSITIVE_HINTS.get((ext_group, rule_name))
            if hint:
                return f'Likely false positive: {hint}'
        return ''


def _serialize_matches(matches: Optional[List[SecurityMatch]]) -> List[Dict]:
    """Serialize SecurityMatch objects for cache storage"""
    if not matches:
        return []
    return [
        {
            'rule_name': m.rule_name,
            'severity': m.severity.value if m.severity else 'WARNING',
            'description': m.description,
            'offset': m.offset,
            'context': m.context
        }
        for m in matches
    ]


def _deserialize_matches(cached_matches: List[Dict]) -> List[SecurityMatch]:
    """Reconstruct SecurityMatch objects from cached data"""
    return [
        SecurityMatch(
            rule_name=m.get('rule_name', 'Unknown'),
            severity=SecuritySeverity(m.get('severity', 'WARNING')),
            description=m.get('description', ''),
            offset=m.get('offset'),
            context=m.get('context', '')
        )
        for m in cached_matches
    ]


class AdvancedMalwareDetector:
    """Combines all malware detection strategies

    Integrates:
    - ClamAV virus scanning (CRITICAL severity)
    - Hash-based blacklist (CRITICAL severity)
    - YARA pattern matching (WARNING severity by default)

    All three are optional and configured independently.

    Severity-based actions:
    - CRITICAL: Auto-quarantine, delete from DB
    - WARNING: Log and flag, user decides
    - INFO: Log only
    """

    def __init__(self, config: Optional[MalwareDetectionConfig] = None):
        """Initialize malware detector

        Args:
            config: Detection configuration (uses defaults if None)
        """
        self.config = config or MalwareDetectionConfig()

        # Initialize enabled strategies
        self.clamav = None
        self.hash_blacklist = None
        self.yara = None
        self._allowlist: Optional[Set[str]] = None

        if self.config.clamav_enabled:
            self.clamav = ClamAVStrategy(self.config.clamav_socket)

        if self.config.hash_blacklist_enabled:
            self.hash_blacklist = HashBlacklistStrategy(self.config.hash_blacklist_path)

        if self.config.yara_enabled:
            self.yara = YARAStrategy(self.config.yara_rules_path)

    def _load_allowlist(self) -> Set[str]:
        """Load allowlist of known-safe file hashes

        Returns:
            Set of SHA256 hashes (lowercase) that should skip security checks
        """
        if self._allowlist is None:
            allowlist_path = Path(self.config.allowlist_path)
            self._allowlist = _load_hash_list(allowlist_path, "allowlist")
        return self._allowlist

    def is_allowlisted(self, file_path: Path) -> bool:
        """Check if file is in allowlist (skip all security checks)

        Args:
            file_path: Path to file to check

        Returns:
            True if file hash is in allowlist
        """
        allowlist = self._load_allowlist()
        if not allowlist:
            return False

        try:
            file_hash = HashBlacklistStrategy._calculate_sha256(file_path)
            return file_hash.lower() in allowlist
        except Exception:
            return False

    def validate(self, file_path: Path, expected_type: str) -> ValidationResult:
        """Run all enabled malware detection strategies

        Uses caching to skip expensive scans for unchanged files.
        Cache key is the file's SHA256 hash.

        Args:
            file_path: Path to file to scan
            expected_type: Expected file type

        Returns:
            ValidationResult with severity-based action hints
        """
        # Check allowlist first - skip all checks if allowlisted
        if self.is_allowlisted(file_path):
            return ValidationResult(
                is_valid=True,
                file_type=expected_type,
                reason='Allowlisted'
            )

        # Calculate file hash for cache lookup
        try:
            file_hash = HashBlacklistStrategy._calculate_sha256(file_path)
        except Exception:
            file_hash = None

        # Check cache first (skip expensive scans for unchanged files)
        if file_hash:
            cached = self._get_cached_result(file_hash, expected_type)
            if cached:
                return cached

        # Run actual scans
        result = self._run_scans(file_path, expected_type)

        # Cache the result
        if file_hash:
            self._cache_result(file_hash, result)

        return result

    def _get_cached_result(self, file_hash: str, expected_type: str) -> Optional[ValidationResult]:
        """Check cache for previous scan result

        Args:
            file_hash: SHA256 hash of file
            expected_type: Expected file type

        Returns:
            Cached ValidationResult if found, None otherwise
        """
        try:
            from pipeline.security_scan_cache import get_security_cache

            cache = get_security_cache()
            cached = cache.get(file_hash)

            if cached:
                severity = SecuritySeverity(cached.severity) if cached.severity else None
                return ValidationResult(
                    is_valid=cached.is_valid,
                    file_type=expected_type if cached.is_valid else 'malware',
                    reason=cached.reason,
                    validation_check=cached.validation_check,
                    severity=severity,
                    matches=_deserialize_matches(cached.matches)
                )
        except Exception:
            pass

        return None

    def _cache_result(self, file_hash: str, result: ValidationResult) -> None:
        """Cache scan result for future lookups

        Args:
            file_hash: SHA256 hash of file
            result: ValidationResult to cache
        """
        try:
            from pipeline.security_scan_cache import get_security_cache

            cache = get_security_cache()
            cache.set(
                file_hash=file_hash,
                is_valid=result.is_valid,
                severity=result.severity.value if result.severity else None,
                reason=result.reason,
                validation_check=result.validation_check or '',
                matches=_serialize_matches(result.matches)
            )
        except Exception:
            pass

    def _run_scans(self, file_path: Path, expected_type: str) -> ValidationResult:
        """Run all enabled malware detection scans"""
        result = self._run_critical_scans(file_path, expected_type)
        if not result.is_valid:
            return result

        warnings = self._run_yara_scan(file_path, expected_type)
        if isinstance(warnings, ValidationResult):
            return warnings

        return self._build_scan_result(expected_type, warnings)

    def _run_critical_scans(self, file_path: Path, expected_type: str) -> ValidationResult:
        """Run critical scans that block immediately (ClamAV, hash blacklist)"""
        for scanner in [self.clamav, self.hash_blacklist]:
            if scanner:
                result = scanner.validate(file_path, expected_type)
                if not result.is_valid:
                    return result
        return ValidationResult(is_valid=True, file_type=expected_type, reason='')

    def _run_yara_scan(
        self, file_path: Path, expected_type: str
    ) -> List[SecurityMatch] | ValidationResult:
        """Run YARA scan, returns warnings list or blocking result"""
        if not self.yara:
            return []

        result = self.yara.validate(
            file_path, expected_type, warning_only=self.config.yara_warning_only
        )
        if not result.is_valid:
            return result
        return list(result.matches) if result.matches else []

    def _build_scan_result(
        self, expected_type: str, warnings: List[SecurityMatch]
    ) -> ValidationResult:
        """Build final scan result, including any warnings"""
        if warnings:
            return ValidationResult(
                is_valid=True,
                file_type=expected_type,
                reason=f'Warnings: {len(warnings)} pattern matches',
                severity=SecuritySeverity.WARNING,
                matches=warnings
            )
        return ValidationResult(is_valid=True, file_type=expected_type, reason='')

    def is_enabled(self) -> bool:
        """Check if any malware detection is enabled

        Returns:
            True if at least one strategy is enabled
        """
        return any([
            self.config.clamav_enabled,
            self.config.hash_blacklist_enabled,
            self.config.yara_enabled
        ])
