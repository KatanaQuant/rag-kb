"""Advanced malware detection strategies

Implements three layers of malware detection:
1. ClamAV integration - Virus signature scanning
2. Hash-based blacklist - Known malware database
3. YARA rules - Custom pattern matching

All three are optional and can be enabled/disabled via configuration.
"""
from pathlib import Path
from typing import Optional, List, Dict
import hashlib
from dataclasses import dataclass

from ingestion.validation_result import ValidationResult


@dataclass
class MalwareDetectionConfig:
    """Configuration for malware detection features"""
    clamav_enabled: bool = False
    clamav_socket: str = "/var/run/clamav/clamd.ctl"
    hash_blacklist_enabled: bool = False
    hash_blacklist_path: str = "/app/data/malware_hashes.txt"
    yara_enabled: bool = False
    yara_rules_path: str = "/app/config/yara_rules.yar"


class ClamAVStrategy:
    """Virus signature scanning using ClamAV

    Requires ClamAV daemon (clamd) to be running.
    Install: apt-get install clamav-daemon
    """

    def __init__(self, socket_path: str = "/var/run/clamav/clamd.ctl"):
        """Initialize ClamAV scanner

        Args:
            socket_path: Path to ClamAV unix socket
        """
        self.socket_path = socket_path
        self._clamd = None

    def _get_client(self):
        """Get ClamAV client (lazy initialization)"""
        if self._clamd is None:
            try:
                import clamd
                self._clamd = clamd.ClamdUnixSocket(self.socket_path)
                # Test connection
                self._clamd.ping()
            except ImportError:
                raise RuntimeError(
                    "ClamAV integration requires 'clamd' package. "
                    "Install with: pip install clamd"
                )
            except Exception as e:
                raise RuntimeError(
                    f"Cannot connect to ClamAV daemon at {self.socket_path}. "
                    f"Ensure clamd is running. Error: {e}"
                )
        return self._clamd

    def validate(self, file_path: Path, expected_type: str) -> ValidationResult:
        """Scan file for viruses using ClamAV

        Args:
            file_path: Path to file to scan
            expected_type: Expected file type

        Returns:
            ValidationResult with is_valid=False if malware detected
        """
        try:
            client = self._get_client()
            scan_result = client.scan(str(file_path))

            # scan_result format: {'/path/to/file': ('FOUND', 'Virus.Name')}
            if scan_result:
                for path, (status, virus_name) in scan_result.items():
                    if status == 'FOUND':
                        return ValidationResult(
                            is_valid=False,
                            file_type='malware',
                            reason=f'Virus detected: {virus_name}',
                            validation_check='ClamAVStrategy'
                        )

            return ValidationResult(
                is_valid=True,
                file_type=expected_type,
                reason=''
            )

        except RuntimeError as e:
            # ClamAV not available - log warning but don't fail
            print(f"  ⚠️  ClamAV scan skipped: {e}")
            return ValidationResult(
                is_valid=True,
                file_type=expected_type,
                reason=''
            )
        except Exception as e:
            # Unexpected error - log but don't fail validation
            print(f"  ⚠️  ClamAV scan error: {e}")
            return ValidationResult(
                is_valid=True,
                file_type=expected_type,
                reason=''
            )


class HashBlacklistStrategy:
    """Hash-based malware blacklist

    Checks file SHA256 hash against known malware database.
    Blacklist format: One SHA256 hash per line (hex format)

    Example blacklist file:
        # VirusTotal known malware
        d41d8cd98f00b204e9800998ecf8427e
        098f6bcd4621d373cade4e832627b4f6
        # Custom blacklist
        abc123def456...
    """

    def __init__(self, blacklist_path: Optional[str] = "/app/data/malware_hashes.txt"):
        """Initialize hash blacklist

        Args:
            blacklist_path: Path to blacklist file (None to disable)
        """
        self.blacklist_path = Path(blacklist_path) if blacklist_path else None
        self._blacklist: Optional[set] = None

    def _load_blacklist(self) -> set:
        """Load blacklist from file (lazy loading)

        Returns:
            Set of blacklisted hashes (lowercase)
        """
        if self._blacklist is None:
            self._blacklist = set()

            if self.blacklist_path is None:
                return self._blacklist

            if not self.blacklist_path.exists():
                print(f"  ⚠️  Hash blacklist not found: {self.blacklist_path}")
                print(f"     Create file with one SHA256 hash per line")
                return self._blacklist

            try:
                with open(self.blacklist_path, 'r') as f:
                    for line in f:
                        line = line.strip()
                        # Skip comments and empty lines
                        if line and not line.startswith('#'):
                            # Store lowercase for case-insensitive comparison
                            self._blacklist.add(line.lower())

                print(f"  ✓ Loaded {len(self._blacklist)} hashes from blacklist")

            except Exception as e:
                print(f"  ⚠️  Failed to load hash blacklist: {e}")

        return self._blacklist

    def validate(self, file_path: Path, expected_type: str) -> ValidationResult:
        """Check file hash against blacklist

        Args:
            file_path: Path to file to check
            expected_type: Expected file type

        Returns:
            ValidationResult with is_valid=False if hash is blacklisted
        """
        blacklist = self._load_blacklist()

        if not blacklist:
            # No blacklist loaded, pass validation
            return ValidationResult(
                is_valid=True,
                file_type=expected_type,
                reason=''
            )

        try:
            # Calculate SHA256 hash
            file_hash = self._calculate_sha256(file_path)

            # Check against blacklist
            if file_hash.lower() in blacklist:
                return ValidationResult(
                    is_valid=False,
                    file_type='malware',
                    reason=f'Known malware hash: {file_hash[:16]}...',
                    validation_check='HashBlacklistStrategy'
                )

            return ValidationResult(
                is_valid=True,
                file_type=expected_type,
                reason=''
            )

        except Exception as e:
            print(f"  ⚠️  Hash blacklist check error: {e}")
            return ValidationResult(
                is_valid=True,
                file_type=expected_type,
                reason=''
            )

    @staticmethod
    def _calculate_sha256(file_path: Path) -> str:
        """Calculate SHA256 hash of file

        Args:
            file_path: Path to file

        Returns:
            Hex-encoded SHA256 hash
        """
        sha256_hash = hashlib.sha256()
        with open(file_path, "rb") as f:
            # Read in chunks to handle large files
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        return sha256_hash.hexdigest()


class YARAStrategy:
    """YARA rule-based pattern matching

    Custom pattern matching for malware detection.
    Install: pip install yara-python

    Example YARA rule file:
        rule SuspiciousScript {
            strings:
                $cmd1 = "rm -rf /" nocase
                $cmd2 = "curl | bash" nocase
                $cmd3 = "wget | sh" nocase
            condition:
                any of them
        }

        rule Cryptocurrency_Miner {
            strings:
                $str1 = "stratum+tcp://"
                $str2 = "xmrig"
                $str3 = "cryptonight"
            condition:
                any of them
        }
    """

    def __init__(self, rules_path: Optional[str] = "/app/config/yara_rules.yar"):
        """Initialize YARA scanner

        Args:
            rules_path: Path to YARA rules file (None to disable)
        """
        self.rules_path = Path(rules_path) if rules_path else None
        self._rules = None

    def _load_rules(self):
        """Load YARA rules (lazy loading)"""
        if self._rules is None:
            try:
                import yara

                if self.rules_path is None:
                    return None

                if not self.rules_path.exists():
                    print(f"  ⚠️  YARA rules not found: {self.rules_path}")
                    print(f"     Create .yar file with YARA rules")
                    return None

                self._rules = yara.compile(filepath=str(self.rules_path))
                print(f"  ✓ Loaded YARA rules from {self.rules_path}")

            except ImportError:
                print("  ⚠️  YARA integration requires 'yara-python' package.")
                print("     Install with: pip install yara-python")
                return None
            except Exception as e:
                print(f"  ⚠️  Failed to load YARA rules: {e}")
                return None

        return self._rules

    def validate(self, file_path: Path, expected_type: str) -> ValidationResult:
        """Scan file with YARA rules

        Args:
            file_path: Path to file to scan
            expected_type: Expected file type

        Returns:
            ValidationResult with is_valid=False if YARA rule matches
        """
        rules = self._load_rules()

        if rules is None:
            # YARA not available, pass validation
            return ValidationResult(
                is_valid=True,
                file_type=expected_type,
                reason=''
            )

        try:
            # Scan file with YARA rules
            matches = rules.match(filepath=str(file_path))

            if matches:
                # Get names of matched rules
                rule_names = [match.rule for match in matches]
                return ValidationResult(
                    is_valid=False,
                    file_type='suspicious',
                    reason=f'YARA rules matched: {", ".join(rule_names)}',
                    validation_check='YARAStrategy'
                )

            return ValidationResult(
                is_valid=True,
                file_type=expected_type,
                reason=''
            )

        except Exception as e:
            print(f"  ⚠️  YARA scan error: {e}")
            return ValidationResult(
                is_valid=True,
                file_type=expected_type,
                reason=''
            )


class AdvancedMalwareDetector:
    """Combines all malware detection strategies

    Integrates:
    - ClamAV virus scanning
    - Hash-based blacklist
    - YARA pattern matching

    All three are optional and configured independently.
    """

    def __init__(self, config: Optional[MalwareDetectionConfig] = None):
        """Initialize malware detector

        Args:
            config: Detection configuration (uses defaults if None)
        """
        self.config = config or MalwareDetectionConfig()

        # Initialize enabled strategies
        self.clamav = None
        self.hash_blacklist = None
        self.yara = None

        if self.config.clamav_enabled:
            self.clamav = ClamAVStrategy(self.config.clamav_socket)

        if self.config.hash_blacklist_enabled:
            self.hash_blacklist = HashBlacklistStrategy(self.config.hash_blacklist_path)

        if self.config.yara_enabled:
            self.yara = YARAStrategy(self.config.yara_rules_path)

    def validate(self, file_path: Path, expected_type: str) -> ValidationResult:
        """Run all enabled malware detection strategies

        Args:
            file_path: Path to file to scan
            expected_type: Expected file type

        Returns:
            ValidationResult (fails on first detection)
        """
        # Check ClamAV first (most comprehensive)
        if self.clamav:
            result = self.clamav.validate(file_path, expected_type)
            if not result.is_valid:
                return result

        # Check hash blacklist (fastest)
        if self.hash_blacklist:
            result = self.hash_blacklist.validate(file_path, expected_type)
            if not result.is_valid:
                return result

        # Check YARA rules last (custom patterns)
        if self.yara:
            result = self.yara.validate(file_path, expected_type)
            if not result.is_valid:
                return result

        # All checks passed
        return ValidationResult(
            is_valid=True,
            file_type=expected_type,
            reason=''
        )

    def is_enabled(self) -> bool:
        """Check if any malware detection is enabled

        Returns:
            True if at least one strategy is enabled
        """
        return any([
            self.config.clamav_enabled,
            self.config.hash_blacklist_enabled,
            self.config.yara_enabled
        ])
