"""Tests for advanced malware detection (Phase 3)"""
import pytest
from pathlib import Path
import tempfile
import shutil
from unittest.mock import Mock, patch, MagicMock

from ingestion.malware_detection import (
    ClamAVStrategy,
    HashBlacklistStrategy,
    YARAStrategy,
    AdvancedMalwareDetector
)
from config import MalwareDetectionConfig


class TestHashBlacklistStrategy:
    """Test hash blacklist malware detection"""

    @pytest.fixture
    def temp_dir(self):
        """Create temporary directory"""
        temp = tempfile.mkdtemp()
        yield Path(temp)
        shutil.rmtree(temp)

    @pytest.fixture
    def blacklist_file(self, temp_dir):
        """Create temporary blacklist file"""
        blacklist = temp_dir / "malware_hashes.txt"
        blacklist.write_text("""# Test malware hashes
# One hash per line
d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2
e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3
# Mixed case should work
F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4F4
""")
        return blacklist

    def test_hash_blacklist_rejects_known_malware(self, temp_dir, blacklist_file):
        """Test hash blacklist rejects files with known malware hashes"""
        # Create test file with known malicious content
        test_file = temp_dir / "malware.pdf"
        test_file.write_bytes(b"D" * 100)  # Content that hashes to d2d2... when calculated

        # Mock SHA256 to return blacklisted hash
        strategy = HashBlacklistStrategy(str(blacklist_file))

        with patch.object(strategy, '_calculate_sha256', return_value='d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2'):
            result = strategy.validate(test_file, 'pdf')

        assert result.is_valid is False
        assert result.validation_check == 'HashBlacklistStrategy'
        assert 'Known malware hash' in result.reason
        assert result.file_type == 'malware'

    def test_hash_blacklist_allows_clean_files(self, temp_dir, blacklist_file):
        """Test hash blacklist allows files not in blacklist"""
        test_file = temp_dir / "clean.pdf"
        test_file.write_bytes(b"Clean content")

        # Mock SHA256 to return clean hash (not in blacklist)
        strategy = HashBlacklistStrategy(str(blacklist_file))

        with patch.object(strategy, '_calculate_sha256', return_value='a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1'):
            result = strategy.validate(test_file, 'pdf')

        assert result.is_valid is True
        assert result.file_type == 'pdf'

    def test_hash_blacklist_case_insensitive(self, temp_dir, blacklist_file):
        """Test hash blacklist is case-insensitive"""
        test_file = temp_dir / "malware.pdf"
        test_file.write_bytes(b"Content")

        strategy = HashBlacklistStrategy(str(blacklist_file))

        # Return uppercase hash, blacklist has lowercase
        with patch.object(strategy, '_calculate_sha256', return_value='D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2D2'):
            result = strategy.validate(test_file, 'pdf')

        assert result.is_valid is False

    def test_hash_blacklist_ignores_comments(self, temp_dir):
        """Test hash blacklist ignores comment lines"""
        blacklist = temp_dir / "blacklist.txt"
        blacklist.write_text("""# This is a comment
# Another comment
# Not a hash: this is just text
""")

        strategy = HashBlacklistStrategy(str(blacklist))
        blacklist_hashes = strategy._load_blacklist()

        # Should be empty (no valid hashes)
        assert len(blacklist_hashes) == 0

    def test_hash_blacklist_empty_when_file_missing(self, temp_dir):
        """Test hash blacklist returns empty set when file missing"""
        strategy = HashBlacklistStrategy(str(temp_dir / "nonexistent.txt"))
        result = strategy.validate(temp_dir / "test.pdf", 'pdf')

        # Should pass validation (no blacklist to check against)
        assert result.is_valid is True

    def test_hash_blacklist_disabled_when_none(self):
        """Test hash blacklist disabled when path is None"""
        strategy = HashBlacklistStrategy(None)
        test_file = Path("/tmp/test.pdf")

        result = strategy.validate(test_file, 'pdf')

        assert result.is_valid is True


class TestClamAVStrategy:
    """Test ClamAV virus scanning"""

    def test_clamav_rejects_infected_file(self):
        """Test ClamAV rejects virus-infected files"""
        with patch('builtins.__import__') as mock_import:
            # Mock clamd module
            mock_clamd = MagicMock()
            mock_client = MagicMock()
            mock_client.ping.return_value = True
            mock_client.scan.return_value = {
                '/test/virus.pdf': ('FOUND', 'Win.Test.EICAR_HDB-1')
            }
            mock_clamd.ClamdUnixSocket.return_value = mock_client

            def import_side_effect(name, *args, **kwargs):
                if name == 'clamd':
                    return mock_clamd
                return __import__(name, *args, **kwargs)

            mock_import.side_effect = import_side_effect

            strategy = ClamAVStrategy('/var/run/clamav/clamd.ctl')
            result = strategy.validate(Path('/test/virus.pdf'), 'pdf')

            assert result.is_valid is False
            assert result.validation_check == 'ClamAVStrategy'
            assert 'Virus detected: Win.Test.EICAR_HDB-1' in result.reason
            assert result.file_type == 'malware'

    def test_clamav_allows_clean_file(self):
        """Test ClamAV allows clean files"""
        with patch('builtins.__import__') as mock_import:
            mock_clamd = MagicMock()
            mock_client = MagicMock()
            mock_client.ping.return_value = True
            mock_client.scan.return_value = {
                '/test/clean.pdf': ('OK', None)
            }
            mock_clamd.ClamdUnixSocket.return_value = mock_client

            def import_side_effect(name, *args, **kwargs):
                if name == 'clamd':
                    return mock_clamd
                return __import__(name, *args, **kwargs)

            mock_import.side_effect = import_side_effect

            strategy = ClamAVStrategy('/var/run/clamav/clamd.ctl')
            result = strategy.validate(Path('/test/clean.pdf'), 'pdf')

            assert result.is_valid is True
            assert result.file_type == 'pdf'

    def test_clamav_handles_connection_error(self):
        """Test ClamAV handles connection errors gracefully"""
        with patch('builtins.__import__') as mock_import:
            mock_clamd = MagicMock()
            mock_client = MagicMock()
            mock_client.ping.side_effect = ConnectionRefusedError("ClamAV not running")
            mock_clamd.ClamdUnixSocket.return_value = mock_client

            def import_side_effect(name, *args, **kwargs):
                if name == 'clamd':
                    return mock_clamd
                return __import__(name, *args, **kwargs)

            mock_import.side_effect = import_side_effect

            strategy = ClamAVStrategy('/var/run/clamav/clamd.ctl')
            result = strategy.validate(Path('/test/file.pdf'), 'pdf')

            # Should pass validation when ClamAV unavailable (fail open)
            assert result.is_valid is True

    def test_clamav_disabled_when_socket_none(self):
        """Test ClamAV disabled when socket is None"""
        strategy = ClamAVStrategy(None)
        result = strategy.validate(Path('/test/file.pdf'), 'pdf')

        assert result.is_valid is True

    def test_clamav_empty_scan_result(self):
        """Test ClamAV handles empty scan results"""
        with patch('builtins.__import__') as mock_import:
            mock_clamd = MagicMock()
            mock_client = MagicMock()
            mock_client.ping.return_value = True
            mock_client.scan.return_value = None  # Empty result
            mock_clamd.ClamdUnixSocket.return_value = mock_client

            def import_side_effect(name, *args, **kwargs):
                if name == 'clamd':
                    return mock_clamd
                return __import__(name, *args, **kwargs)

            mock_import.side_effect = import_side_effect

            strategy = ClamAVStrategy('/var/run/clamav/clamd.ctl')
            result = strategy.validate(Path('/test/file.pdf'), 'pdf')

            assert result.is_valid is True


class TestYARAStrategy:
    """Test YARA pattern matching"""

    @pytest.fixture
    def temp_dir(self):
        """Create temporary directory"""
        temp = tempfile.mkdtemp()
        yield Path(temp)
        shutil.rmtree(temp)

    @pytest.fixture
    def yara_rules_file(self, temp_dir):
        """Create temporary YARA rules file"""
        rules = temp_dir / "test_rules.yar"
        rules.write_text("""
rule Test_Malware {
    meta:
        description = "Test malware pattern"

    strings:
        $malicious = "MALICIOUS_PATTERN"

    condition:
        $malicious
}

rule Test_Suspicious {
    strings:
        $suspicious = "SUSPICIOUS"

    condition:
        $suspicious
}
""")
        return rules

    def test_yara_rejects_matching_files(self, temp_dir, yara_rules_file):
        """Test YARA rejects files matching rules"""
        test_file = temp_dir / "malware.pdf"
        test_file.write_text("This file contains MALICIOUS_PATTERN")

        with patch('builtins.__import__') as mock_import:
            mock_yara = MagicMock()
            mock_match = MagicMock()
            mock_match.rule = "Test_Malware"

            mock_rules = MagicMock()
            mock_rules.match.return_value = [mock_match]
            mock_yara.compile.return_value = mock_rules

            def import_side_effect(name, *args, **kwargs):
                if name == 'yara':
                    return mock_yara
                return __import__(name, *args, **kwargs)

            mock_import.side_effect = import_side_effect

            strategy = YARAStrategy(str(yara_rules_file))
            result = strategy.validate(test_file, 'pdf')

            assert result.is_valid is False
            assert result.validation_check == 'YARAStrategy'
            assert 'YARA rules matched: Test_Malware' in result.reason
            assert result.file_type == 'suspicious'

    def test_yara_allows_clean_files(self, temp_dir, yara_rules_file):
        """Test YARA allows files not matching rules"""
        test_file = temp_dir / "clean.pdf"
        test_file.write_text("This is clean content")

        with patch('builtins.__import__') as mock_import:
            mock_yara = MagicMock()
            mock_rules = MagicMock()
            mock_rules.match.return_value = []
            mock_yara.compile.return_value = mock_rules

            def import_side_effect(name, *args, **kwargs):
                if name == 'yara':
                    return mock_yara
                return __import__(name, *args, **kwargs)

            mock_import.side_effect = import_side_effect

            strategy = YARAStrategy(str(yara_rules_file))
            result = strategy.validate(test_file, 'pdf')

            assert result.is_valid is True
            assert result.file_type == 'pdf'

    def test_yara_multiple_matches(self, temp_dir, yara_rules_file):
        """Test YARA reports multiple matching rules"""
        test_file = temp_dir / "suspicious.pdf"
        test_file.write_text("MALICIOUS_PATTERN and SUSPICIOUS content")

        with patch('builtins.__import__') as mock_import:
            mock_yara = MagicMock()
            mock_match1 = MagicMock()
            mock_match1.rule = "Test_Malware"
            mock_match2 = MagicMock()
            mock_match2.rule = "Test_Suspicious"

            mock_rules = MagicMock()
            mock_rules.match.return_value = [mock_match1, mock_match2]
            mock_yara.compile.return_value = mock_rules

            def import_side_effect(name, *args, **kwargs):
                if name == 'yara':
                    return mock_yara
                return __import__(name, *args, **kwargs)

            mock_import.side_effect = import_side_effect

            strategy = YARAStrategy(str(yara_rules_file))
            result = strategy.validate(test_file, 'pdf')

            assert result.is_valid is False
            assert 'Test_Malware' in result.reason
            assert 'Test_Suspicious' in result.reason

    def test_yara_handles_compile_error(self, temp_dir):
        """Test YARA handles rule compilation errors"""
        bad_rules = temp_dir / "bad_rules.yar"
        bad_rules.write_text("invalid yara syntax {{{")

        with patch('builtins.__import__') as mock_import:
            mock_yara = MagicMock()
            mock_yara.compile.side_effect = Exception("Syntax error")

            def import_side_effect(name, *args, **kwargs):
                if name == 'yara':
                    return mock_yara
                return __import__(name, *args, **kwargs)

            mock_import.side_effect = import_side_effect

            strategy = YARAStrategy(str(bad_rules))
            result = strategy.validate(temp_dir / "test.pdf", 'pdf')

            # Should pass validation when rules fail to compile (fail open)
            assert result.is_valid is True

    def test_yara_disabled_when_path_none(self):
        """Test YARA disabled when rules path is None"""
        strategy = YARAStrategy(None)
        result = strategy.validate(Path('/test/file.pdf'), 'pdf')

        assert result.is_valid is True

    def test_yara_disabled_when_file_missing(self, temp_dir):
        """Test YARA disabled when rules file doesn't exist"""
        strategy = YARAStrategy(str(temp_dir / "nonexistent.yar"))
        result = strategy.validate(temp_dir / "test.pdf", 'pdf')

        assert result.is_valid is True


class TestAdvancedMalwareDetector:
    """Test combined malware detection"""

    @pytest.fixture
    def temp_dir(self):
        """Create temporary directory"""
        temp = tempfile.mkdtemp()
        yield Path(temp)
        shutil.rmtree(temp)

    def test_detector_runs_all_enabled_strategies(self, temp_dir):
        """Test detector runs all enabled strategies"""
        config = MalwareDetectionConfig(
            clamav_enabled=True,
            clamav_socket="/var/run/clamav/clamd.ctl",
            hash_blacklist_enabled=True,
            hash_blacklist_path=str(temp_dir / "hashes.txt"),
            yara_enabled=True,
            yara_rules_path=str(temp_dir / "rules.yar")
        )

        # Create empty config files
        (temp_dir / "hashes.txt").touch()
        (temp_dir / "rules.yar").write_text("rule Test { condition: false }")

        with patch('ingestion.malware_detection.ClamAVStrategy') as mock_clamav, \
             patch('ingestion.malware_detection.HashBlacklistStrategy') as mock_hash, \
             patch('ingestion.malware_detection.YARAStrategy') as mock_yara:

            detector = AdvancedMalwareDetector(config)

            # Verify all strategies were created
            assert detector.clamav is not None
            assert detector.hash_blacklist is not None
            assert detector.yara is not None

    def test_detector_skips_disabled_strategies(self):
        """Test detector skips disabled strategies"""
        config = MalwareDetectionConfig(
            clamav_enabled=False,
            hash_blacklist_enabled=False,
            yara_enabled=False
        )

        detector = AdvancedMalwareDetector(config)

        assert detector.clamav is None
        assert detector.hash_blacklist is None
        assert detector.yara is None

    def test_detector_rejects_on_first_failure(self, temp_dir):
        """Test detector stops on first strategy failure"""
        config = MalwareDetectionConfig(
            clamav_enabled=True,
            clamav_socket="/var/run/clamav/clamd.ctl",
            hash_blacklist_enabled=True,
            hash_blacklist_path=str(temp_dir / "hashes.txt")
        )

        (temp_dir / "hashes.txt").touch()

        detector = AdvancedMalwareDetector(config)
        test_file = temp_dir / "test.pdf"
        test_file.touch()

        # Mock ClamAV to fail
        from ingestion.validation_result import ValidationResult
        detector.clamav = Mock()
        detector.clamav.validate.return_value = ValidationResult(
            is_valid=False,
            file_type='malware',
            reason='Virus detected',
            validation_check='ClamAVStrategy'
        )

        # Mock hash blacklist (shouldn't be called)
        detector.hash_blacklist = Mock()

        result = detector.validate(test_file, 'pdf')

        # Should reject and not call hash_blacklist
        assert result.is_valid is False
        assert result.reason == 'Virus detected'
        detector.hash_blacklist.validate.assert_not_called()

    def test_detector_passes_when_all_clean(self, temp_dir):
        """Test detector passes when all strategies pass"""
        config = MalwareDetectionConfig(
            clamav_enabled=True,
            clamav_socket="/var/run/clamav/clamd.ctl",
            hash_blacklist_enabled=True,
            hash_blacklist_path=str(temp_dir / "hashes.txt"),
            yara_enabled=True,
            yara_rules_path=str(temp_dir / "rules.yar")
        )

        (temp_dir / "hashes.txt").touch()
        (temp_dir / "rules.yar").write_text("rule Test { condition: false }")

        detector = AdvancedMalwareDetector(config)
        test_file = temp_dir / "clean.pdf"
        test_file.touch()

        # Mock all strategies to pass
        from ingestion.validation_result import ValidationResult
        clean_result = ValidationResult(is_valid=True, file_type='pdf', reason='')

        detector.clamav = Mock()
        detector.clamav.validate.return_value = clean_result

        detector.hash_blacklist = Mock()
        detector.hash_blacklist.validate.return_value = clean_result

        detector.yara = Mock()
        detector.yara.validate.return_value = clean_result

        result = detector.validate(test_file, 'pdf')

        # Should pass
        assert result.is_valid is True
        assert result.file_type == 'pdf'

        # All strategies should have been called
        detector.clamav.validate.assert_called_once()
        detector.hash_blacklist.validate.assert_called_once()
        detector.yara.validate.assert_called_once()

    def test_detector_passes_when_all_disabled(self):
        """Test detector passes validation when all strategies disabled"""
        config = MalwareDetectionConfig(
            clamav_enabled=False,
            hash_blacklist_enabled=False,
            yara_enabled=False
        )

        detector = AdvancedMalwareDetector(config)
        result = detector.validate(Path('/test/file.pdf'), 'pdf')

        # Should pass (no checks to run)
        assert result.is_valid is True
